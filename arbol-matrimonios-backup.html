<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>√Årbol Geneal√≥gico - Matrimonios</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: #fafafa;
        }
        
        #tree-container {
            width: 100%;
            height: 1200px; /* Aumentado para mejor espaciado */
            border: 1px solid #e5e7eb;
            border-radius: 8px; 
            background: white;
            overflow: auto; /* Scroll si es necesario */
        }
        
        .marriage-unit {
            cursor: pointer;
        }

        .person-card {
            fill: white;
            stroke: #d1d5db;
            stroke-width: 2;
            rx: 12; /* Bordes redondeados como en la referencia */
            filter: drop-shadow(0 2px 8px rgba(0,0,0,0.1)); /* Sombra sutil */
        }
        
        .person-text {
            font-size: 14px; /* Texto m√°s grande para tarjetas m√°s grandes */
            fill: #374151;
            text-anchor: middle;
            font-weight: 500;
        }
        
        .person-text.name {
            font-size: 14px; /* Reducido para tarjetas m√°s estrechas */
            font-weight: 600;
            fill: #111827;
        }
        
        .person-text.dates {
            font-size: 11px;
            fill: #6b7280;
        }
        
        .marriage-link {
            stroke: #f59e0b;
            stroke-width: 3;
        }

        .parent-child-link {
            stroke: #6b7280;
            stroke-width: 2;
            fill: none;
        }
        
        .connection-point {
            fill: #6b7280;
            stroke: white;
            stroke-width: 1;
        }
        
        .collapsed {
            opacity: 0.6;
        }
        
        .status {
            position: fixed;
            top: 20px;
            left: 20px;
            background: white;
            padding: 10px;
            border-radius: 6px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>
    <div class="status" id="status">Cargando...</div>
    
    <h1>üå≥ √Årbol Geneal√≥gico - Centrado en Matrimonios</h1>
    <p>Nueva versi√≥n que organiza el √°rbol por matrimonios como unidades b√°sicas</p>
    
    <div style="margin: 20px 0; display: flex; gap: 10px; align-items: center;">
        <button onclick="resetZoom()" style="padding: 8px 16px; background: #3b82f6; color: white; border: none; border-radius: 4px; cursor: pointer;">
            üîç Reset Zoom
                        </button>
        <button onclick="expandAll()" style="padding: 8px 16px; background: #10b981; color: white; border: none; border-radius: 4px; cursor: pointer;">
            üìÇ Expandir Todo
                        </button>
        <button onclick="collapseAll()" style="padding: 8px 16px; background: #ef4444; color: white; border: none; border-radius: 4px; cursor: pointer;">
            üìÅ Colapsar Todo
                    </button>
        <span style="font-size: 14px; color: #6b7280;">
            üí° Usa rueda del mouse para zoom, arrastra para mover, haz click en matrimonios para colapsar/expandir
        </span>
        </div>
        
    <div id="tree-container"></div>

    <script>
        // Configuraci√≥n del Google Sheet (mantenemos la misma)
        const SHEET_ID = '1NQh95vcu2G3fQSkcihojAF9CfXvaQHBmDeol1EM-gn8';
        
        // Variables globales
        let familyData = null;
        let svg = null;
        let marriages = new Map();
        let individuals = {};
        let currentUnits = []; // Estado actual de todas las unidades
        
        // Configuraci√≥n del SVG - Espaciado mejorado para conexiones
        const width = 2400; // Aumentado para m√°s matrimonios horizontalmente
        const height = 1800; // Aumentado para m√°s generaciones
        const cardWidth = 140; // Tarjetas m√°s estrechas 
        const cardHeight = 180; // Mucho m√°s altas que anchas
        const marriageSpacing = 500; // Aumentado para evitar superposici√≥n
        const generationSpacing = 400; // Aumentado para m√°s espacio vertical
        const spouseGap = 25; // Gap m√°s grande entre c√≥nyuges
        
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }
        
        // Funci√≥n principal para cargar datos del Google Sheet
        async function loadData() {
            try {
                updateStatus('Cargando datos...');
                const url = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/gviz/tq?tqx=out:json&gid=0`;
                const response = await fetch(url);
                const text = await response.text();
                
                const match = text.match(/google\.visualization\.Query\.setResponse\((.+)\);?$/);
                if (!match) throw new Error('No se encontr√≥ JSON v√°lido');
                
                const data = JSON.parse(match[1]);
                if (!data.table || !data.table.rows) throw new Error('Formato inv√°lido');
                
                // Procesar filas
                const rows = data.table.rows.map(row => {
                    const cells = row.c || [];
                    
                    return {
                        id: String(cells[0]?.v || '').trim(),
                        name: String(cells[2]?.v || '').trim(),
                        birth_date: cells[3]?.v || '',
                        birth_place: String(cells[4]?.v || '').trim(),
                        death_date: cells[5]?.v || '',
                        death_place: String(cells[6]?.v || '').trim(),
                        spouseId: String(cells[7]?.v || '').trim(),
                        childrenIds: String(cells[8]?.v || '').trim(),
                        fatherId: String(cells[9]?.v || '').trim(),
                        motherId: String(cells[10]?.v || '').trim(),
                        branch: String(cells[11]?.v || '').trim(),
                        generation: parseInt(cells[12]?.v) || 0
                    };
                }).filter(row => row.id && row.name);
                
                console.log('üìä Datos cargados:', rows.length, 'personas');
                console.log('üë• Todas las personas:', rows.map(p => `${p.name} (${p.id})`));
                
                // Debug espec√≠fico para verificar datos de personas clave
                const tomas = rows.find(p => p.id === 'p31');
                const francisca = rows.find(p => p.id === 'p32');
                const emiliana = rows.find(p => p.id === 'p21');
                const celestina = rows.find(p => p.name.includes('Celestina Roh'));
                
                            console.log('üîç TOMAS:', tomas ? `${tomas.name} (${tomas.id}) - SpouseId: ${tomas.spouseId}, Generation: ${tomas.generation}` : 'NO ENCONTRADO');
            console.log('üîç FRANCISCA:', francisca ? `${francisca.name} (${francisca.id}) - SpouseId: ${francisca.spouseId}, Generation: ${francisca.generation}` : 'NO ENCONTRADO');
            console.log('üîç EMILIANA:', emiliana ? `${emiliana.name} (${emiliana.id}) - Padre: ${emiliana.fatherId}, Madre: ${emiliana.motherId}, Spouse: ${emiliana.spouseId}, Generation: ${emiliana.generation}` : 'NO ENCONTRADO');
            console.log('üîç CELESTINA:', celestina ? `${celestina.name} (${celestina.id}) - Padre: ${celestina.fatherId}, Madre: ${celestina.motherId}, Spouse: ${celestina.spouseId}, Generation: ${celestina.generation}` : 'NO ENCONTRADO');
            
            // Debug de generaciones adicionales - buscar por nombre
            const francisco = rows.find(p => p.name.includes('Francisco Clemenzoz'));
            const marie = rows.find(p => p.name.includes('Marie Louise'));
            const francois = rows.find(p => p.name.includes('Francois Clemenzo'));
            const celestinaRoh = rows.find(p => p.name.includes('Celestina Roh'));
            
            console.log('üîç FRANCISCO CLEMENZOZ:', francisco ? `${francisco.name} (${francisco.id}) - Generation: ${francisco.generation}` : 'NO ENCONTRADO');
            console.log('üîç MARIE LOUISE:', marie ? `${marie.name} (${marie.id}) - Generation: ${marie.generation}` : 'NO ENCONTRADO');
            console.log('üîç FRANCOIS:', francois ? `${francois.name} (${francois.id}) - Generation: ${francois.generation}` : 'NO ENCONTRADO');
            console.log('üîç CELESTINA ROH:', celestinaRoh ? `${celestinaRoh.name} (${celestinaRoh.id}) - Generation: ${celestinaRoh.generation}` : 'NO ENCONTRADO');
        

                return rows;
                
            } catch (error) {
                console.error('Error cargando datos:', error);
                updateStatus('Error cargando datos: ' + error.message);
                return [];
            }
        }

        // Construir estructura centrada en matrimonios
        function buildMarriageStructure(rows) {
            updateStatus('Procesando matrimonios...');
            
            // PASO 1: Crear individuos
            individuals = {};
            rows.forEach(row => {
                if (!row.id || !row.name) return;
                
                individuals[row.id] = {
                    id: row.id,
                    name: row.name,
                    birthDate: row.birth_date,
                    birthPlace: row.birth_place,
                    deathDate: row.death_date,
                    deathPlace: row.death_place,
                    generation: row.generation,
                    branch: row.branch,
                    spouseId: row.spouseId || null,
                    fatherId: row.fatherId || null,
                    motherId: row.motherId || null,
                    childrenIds: row.childrenIds ? row.childrenIds.split(',').map(s => s.trim()).filter(s => s) : []
                };
            });
            
            console.log('üë• Individuos creados:', Object.keys(individuals).length);
            
            // PASO 2: Crear matrimonios Y personas solteras
            marriages = new Map();
            const singlePeople = new Map();
            const processedPairs = new Set();
            const processedIndividuals = new Set();
            
            // Crear matrimonios
            Object.values(individuals).forEach(person => {
                if (!person.spouseId || !individuals[person.spouseId]) return;
                
                const key = [person.id, person.spouseId].sort().join('::');
                if (processedPairs.has(key)) return;
                processedPairs.add(key);
                
                const spouse = individuals[person.spouseId];
                if (spouse.spouseId !== person.id) return; // Verificar simetr√≠a
                
                const marriage = {
                    id: key,
                    spouse1: person,
                    spouse2: spouse,
                    children: [],
                    generation: Math.max(person.generation, spouse.generation),
                    collapsed: false,
                    hidden: false,
                    x: 0,
                    y: 0,
                    type: 'marriage'
                };
                
                marriages.set(key, marriage);
                processedIndividuals.add(person.id);
                processedIndividuals.add(spouse.id);
                console.log(`üíç Matrimonio: ${person.name} ‚Üê‚Üí ${spouse.name}`);
                
                // Debug espec√≠fico para matrimonios importantes
                if (person.name.includes('Tomas') || spouse.name.includes('Francisca') || 
                    person.name.includes('Jose Roh') || spouse.name.includes('Maria Putallaz')) {
                    console.log(`  üîç MATRIMONIO CLAVE: ${key} = ${person.name} (${person.id}) + ${spouse.name} (${spouse.id})`);
                }
                
                // Debug espec√≠fico para Tomas + Francisca
                if ((person.id === 'p31' && spouse.id === 'p32') || (person.id === 'p32' && spouse.id === 'p31')) {
                    console.log(`üéØ MATRIMONIO TOMAS+FRANCISCA CREADO: ${person.name} ‚Üê‚Üí ${spouse.name}`);
                }
            });
            
            // Crear entradas para personas solteras (ni√±os, solteros, etc.)
            Object.values(individuals).forEach(person => {
                if (processedIndividuals.has(person.id)) return; // Ya procesado en matrimonio
                
                const singleUnit = {
                    id: person.id,
                    person: person,
                    children: [],
                    generation: person.generation,
                    collapsed: false,
                    hidden: false,
                    x: 0,
                    y: 0,
                    type: 'single'
                };
                
                singlePeople.set(person.id, singleUnit);
                console.log(`üë§ Persona soltera: ${person.name}`);
            });
            
            // PASO 3: Asignar hijos a matrimonios o padres solteros
            Object.values(individuals).forEach(person => {
                if (!person.fatherId && !person.motherId) return;
                
                // Debug para entender qu√© est√° pasando con los matrimonios
                if (person.name.includes('Celestina Roh')) {
                    console.log(`üîç PROCESANDO CELESTINA: ${person.name} busca padres ${person.fatherId} + ${person.motherId}`);
                }
                
                // Buscar si los padres forman un matrimonio
                if (person.fatherId && person.motherId) {
                    const marriageKey = [person.fatherId, person.motherId].sort().join('::');
                    const marriage = marriages.get(marriageKey);
                    
                    if (person.name.includes('Celestina Roh')) {
                        console.log(`üîç CELESTINA marriageKey: ${marriageKey}, marriage found:`, marriage ? `${marriage.spouse1.name}+${marriage.spouse2.name}` : 'NO');
                    }
                    
                    if (marriage) {
                        // IMPORTANTE: No agregar a alguien como hijo de su propio matrimonio
                        if (marriage.spouse1.id === person.id || marriage.spouse2.id === person.id) {
                            console.log(`‚ö†Ô∏è AUTOCONEXI√ìN EVITADA: ${person.name} no se agrega como hijo de su propio matrimonio ${marriage.spouse1.name}+${marriage.spouse2.name}`);
                            return;
                        }
                        
                        // ELIMINADO: L√≥gica de matrimonios hijos - solo usar conexiones padre-hijo individuales
                        // if (person.spouseId && individuals[person.spouseId]) {
                        //     console.log(`üííüë∂ PERSONA CASADA: ${person.name} (casado/a con ${individuals[person.spouseId].name}) se agrega SOLO como matrimonio hijo de ${marriage.spouse1.name}+${marriage.spouse2.name}`);
                        //     
                        //     // Encontrar el matrimonio de esta persona
                        //     const childMarriageKey = [person.id, person.spouseId].sort().join('::');
                        //     const childMarriage = marriages.get(childMarriageKey);
                        //     
                        //     if (childMarriage) {
                        //         // Crear relaci√≥n padre-matrimonio ‚Üí hijo-matrimonio
                        //         if (!marriage.childMarriages) marriage.childMarriages = [];
                        //         marriage.childMarriages.push(childMarriage);
                        //         childMarriage.parentMarriage = marriage;
                        //         console.log(`üíí‚û°Ô∏èüíí CONEXI√ìN MATRIMONIO: ${marriage.spouse1.name}+${marriage.spouse2.name} ‚Üí ${childMarriage.spouse1.name}+${childMarriage.spouse2.name}`);
                        //     }
                        //     return; // NO agregar como hijo individual - solo como matrimonio
                        // }
                        
                        marriage.children.push(person);
                        console.log(`üë∂ ${person.name} ‚Üí ${marriage.spouse1.name} & ${marriage.spouse2.name}`);
                        
                        // Debug espec√≠fico para problemas
                        if (person.name.includes('Celestina Roh') || person.name.includes('Emiliana')) {
                            console.log(`  üîç DEBUG: ${person.name} asignado a matrimonio ${marriage.spouse1.name}+${marriage.spouse2.name}`);
                            console.log(`  üîç Datos: padre=${person.fatherId}, madre=${person.motherId}, marriageKey=${marriageKey}`);
                        }
                        return;
                    }
                }
                
                // Si no hay matrimonio, asignar al padre o madre soltera
                const parentId = person.fatherId || person.motherId;
                const parentSingle = singlePeople.get(parentId);
                if (parentSingle) {
                    parentSingle.children.push(person);
                    console.log(`üë∂ ${person.name} ‚Üí ${parentSingle.person.name} (padre/madre soltera)`);
                }
            });
            
            // PASO 4: Combinar matrimonios y personas solteras
            const allUnits = [];
            marriages.forEach(marriage => allUnits.push(marriage));
            singlePeople.forEach(single => allUnits.push(single));
            
            console.log('üíí Matrimonios procesados:', marriages.size);
            console.log('üë§ Personas solteras procesadas:', singlePeople.size);
            console.log('üèóÔ∏è Total unidades:', allUnits.length);
            
            return allUnits;
        }
        
        // Calcular layout sim√©trico con posicionamiento inteligente de hijos
        function calculateMarriageLayout(marriageArray) {
            updateStatus('Calculando posiciones...');
            
            // NUEVO: Agrupar unidades por generaci√≥n del Google Sheet
            const unitsByGeneration = new Map();
            
            marriageArray.forEach(unit => {
                let generation;
                if (unit.type === 'marriage') {
                    // Para matrimonios, usar la generaci√≥n mayor (m√°s antigua) de los c√≥nyuges
                    generation = Math.max(unit.spouse1.generation, unit.spouse2.generation);
                } else if (unit.type === 'single') {
                    generation = unit.person.generation;
                }
                
                if (!unitsByGeneration.has(generation)) {
                    unitsByGeneration.set(generation, []);
                }
                unitsByGeneration.get(generation).push(unit);
                
                // Debug: mostrar generaci√≥n asignada
                const name = unit.type === 'marriage' ? `${unit.spouse1.name}+${unit.spouse2.name}` : unit.person.name;
                console.log(`üìä GENERACI√ìN ${generation}: ${name} (${unit.type})`);
                
                // Debug espec√≠fico para Francois y Tomas
                if (name.includes('Francois') || name.includes('Tomas')) {
                    if (unit.type === 'marriage') {
                        console.log(`üîç DEBUG ${name}: spouse1.generation=${unit.spouse1.generation}, spouse2.generation=${unit.spouse2.generation}, max=${generation}`);
                    }
                }
            });
            
            // Ordenar generaciones de mayor a menor (6, 5, 4, 3, 2, 1)
            const sortedGenerations = Array.from(unitsByGeneration.keys()).sort((a, b) => b - a);
            
            console.log(`üå≥ GENERACIONES DETECTADAS: ${sortedGenerations.join(', ')}`);
            sortedGenerations.forEach((gen, i) => {
                const units = unitsByGeneration.get(gen);
                console.log(`  Gen ${gen}: ${units.length} unidades`);
                units.forEach(unit => {
                    const name = unit.type === 'marriage' ? `${unit.spouse1.name}+${unit.spouse2.name}` : unit.person.name;
                    console.log(`    - ${name}`);
                });
            });
            
            // Posicionar generaci√≥n por generaci√≥n
            let currentY = 100;
            const positionedUnits = new Set();
            
            function positionLevel(units, y) {
                if (units.length === 0) return;
                
                console.log(`üéØ POSITION LEVEL: Y=${y}, ${units.length} unidades:`);
                units.forEach((unit, i) => {
                    const name = unit.type === 'marriage' ? `${unit.spouse1.name}+${unit.spouse2.name}` : unit.person.name;
                    console.log(`  ${i+1}. ${name} (${unit.type})`);
                });
                
                // Calcular ancho total necesario para esta generaci√≥n
                const totalWidth = units.length * marriageSpacing;
                const startX = (width - totalWidth) / 2;
                
                console.log(`üìê POSICIONAMIENTO: totalWidth=${totalWidth}, startX=${startX}, marriageSpacing=${marriageSpacing}`);
                
                units.forEach((unit, index) => {
                    if (!positionedUnits.has(unit.id)) {
                        unit.x = startX + index * marriageSpacing + marriageSpacing / 2;
                        unit.y = y;
                        
                        const name = unit.type === 'marriage' ? `${unit.spouse1.name}+${unit.spouse2.name}` : unit.person.name;
                        console.log(`üìç POSICIONANDO: ${name} en index=${index}, X=${unit.x}, Y=${unit.y}`);
                        
                        if (unit.type === 'marriage') {
                            // Posicionar c√≥nyuges lado a lado
                            unit.spouse1.x = unit.x - cardWidth / 2 - spouseGap / 2;
                            unit.spouse1.y = unit.y;
                            unit.spouse2.x = unit.x + cardWidth / 2 + spouseGap / 2;
                            unit.spouse2.y = unit.y;
                            
                            console.log(`üìç ${unit.spouse1.name} ‚Üê‚Üí ${unit.spouse2.name} en (${unit.x}, ${unit.y})`);
                        } else if (unit.type === 'single') {
                            // Posicionar persona soltera en el centro
                            unit.person.x = unit.x;
                            unit.person.y = unit.y;
                            
                            console.log(`üìç ${unit.person.name} (soltero/a) en (${unit.x}, ${unit.y})`);
                        }
                        
                        positionedUnits.add(unit.id);
                    }
                });
                
                // ELIMINADO: Posicionamiento de hijos (ahora se hace por generaciones)
                // Los hijos se posicionar√°n autom√°ticamente en sus respectivas generaciones
            }
            
            // Posicionar cada generaci√≥n secuencialmente
            sortedGenerations.forEach((generation, genIndex) => {
                const generationUnits = unitsByGeneration.get(generation);
                const y = 100 + (genIndex * generationSpacing);
                
                console.log(`üéØ POSICIONANDO GENERACI√ìN ${generation} en Y=${y}`);
                positionLevel(generationUnits, y);
                currentY = y + generationSpacing;
            });
            
            return marriageArray;
        }
        
        // Renderizar el √°rbol
        function renderTree(marriageArray) {
            updateStatus('Renderizando √°rbol...');
            
            // Limpiar contenedor
            d3.select('#tree-container').selectAll('*').remove();
            
            // Crear SVG
            svg = d3.select('#tree-container')
                .append('svg')
                .attr('width', width)
                .attr('height', height);
            
            // Configurar zoom y pan
            const zoom = d3.zoom()
                .scaleExtent([0.3, 3])
                .on('zoom', function(event) {
                    g.attr('transform', event.transform);
                });
            
            svg.call(zoom);
            
            const g = svg.append('g');
            
            // Renderizar cada unidad (matrimonio o persona soltera)
            marriageArray.forEach(unit => {
                if (unit.type === 'marriage') {
                    renderMarriage(g, unit, marriageArray);
                } else if (unit.type === 'single') {
                    renderSinglePerson(g, unit, marriageArray);
                }
            });
            
            // Agregar l√≠neas de conexi√≥n padre-hijo
            renderParentChildConnections(g, marriageArray);
            
            updateStatus(`‚úÖ √Årbol renderizado: ${marriageArray.length} unidades`);
        }
        
        // Funci√≥n para renderizar matrimonios
        function renderMarriage(container, marriage, allUnits) {
            const marriageGroup = container.append('g')
                .attr('class', 'marriage-unit')
                .attr('transform', `translate(${marriage.x}, ${marriage.y})`)
                .style('cursor', 'pointer')
                .on('click', function() {
                    toggleMarriageCollapse(marriage);
                });
            
            // L√≠nea de matrimonio con gradiente
            marriageGroup.append('line')
                .attr('class', 'marriage-link')
                .attr('x1', -cardWidth/2 - 10)
                .attr('y1', 0)
                .attr('x2', cardWidth/2 + 10)
                .attr('y2', 0)
                .style('stroke', '#8b5cf6')
                .style('stroke-width', '4')
                .style('stroke-linecap', 'round')
                .style('opacity', '0.9');
            
            // Tarjetas de los c√≥nyuges
            [marriage.spouse1, marriage.spouse2].forEach((spouse, index) => {
                renderPersonCard(marriageGroup, spouse, marriage.x, marriage.y);
            });
            
            // Informaci√≥n del matrimonio e indicador de collapse/expand
            const totalChildren = marriage.children.length + (marriage.childMarriages ? marriage.childMarriages.length : 0);
            if (totalChildren > 0) {
                marriageGroup.append('text')
                    .attr('class', 'person-text')
                    .attr('y', 50)
                    .style('font-size', '10px')
                    .style('fill', '#6b7280')
                    .text(`${totalChildren} hijo${totalChildren > 1 ? 's' : ''}`);
                
                // Indicador de estado collapse/expand con sombra
                marriageGroup.append('circle')
                    .attr('cx', 2)
                    .attr('cy', 72)
                    .attr('r', 8)
                    .style('fill', '#000000')
                    .style('opacity', '0.2');
                
                marriageGroup.append('circle')
                    .attr('cx', 0)
                    .attr('cy', 70)
                    .attr('r', 8)
                    .style('fill', marriage.collapsed ? '#ef4444' : '#10b981')
                    .style('stroke', 'white')
                    .style('stroke-width', '2.5')
                    .style('filter', 'drop-shadow(0 2px 4px rgba(0,0,0,0.1))');
                
                marriageGroup.append('text')
                    .attr('y', 75)
                    .style('font-size', '14px')
                    .style('fill', 'white')
                    .style('text-anchor', 'middle')
                    .style('font-weight', 'bold')
                    .text(marriage.collapsed ? '+' : '‚àí');
            }
        }
        
        // Funci√≥n para renderizar personas solteras
        function renderSinglePerson(container, singleUnit, allUnits) {
            const personGroup = container.append('g')
                .attr('class', 'single-unit')
                .attr('transform', `translate(${singleUnit.x}, ${singleUnit.y})`)
                .style('cursor', 'pointer')
                .on('click', function() {
                    if (singleUnit.children.length > 0) {
                        toggleMarriageCollapse(singleUnit);
                    }
                });
            
            // Renderizar tarjeta de la persona
            renderPersonCard(personGroup, singleUnit.person, singleUnit.x, singleUnit.y);
            
            // Informaci√≥n de hijos e indicador de collapse/expand
            if (singleUnit.children.length > 0) {
                personGroup.append('text')
                    .attr('class', 'person-text')
                    .attr('y', 50)
                    .style('font-size', '10px')
                    .style('fill', '#6b7280')
                    .text(`${singleUnit.children.length} hijo${singleUnit.children.length > 1 ? 's' : ''}`);
                
                // Indicador de estado collapse/expand con sombra
                personGroup.append('circle')
                    .attr('cx', 2)
                    .attr('cy', 72)
                    .attr('r', 8)
                    .style('fill', '#000000')
                    .style('opacity', '0.2');
                
                personGroup.append('circle')
                    .attr('cx', 0)
                    .attr('cy', 70)
                    .attr('r', 8)
                    .style('fill', singleUnit.collapsed ? '#ef4444' : '#10b981')
                    .style('stroke', 'white')
                    .style('stroke-width', '2.5')
                    .style('filter', 'drop-shadow(0 2px 4px rgba(0,0,0,0.1))');
                
                personGroup.append('text')
                    .attr('y', 75)
                    .style('font-size', '14px')
                    .style('fill', 'white')
                    .style('text-anchor', 'middle')
                    .style('font-weight', 'bold')
                    .text(singleUnit.collapsed ? '+' : '‚àí');
            }
        }
        
        // Funci√≥n auxiliar para renderizar tarjeta de persona con dise√±o moderno tipo perfil
        function renderPersonCard(container, person, baseX, baseY) {
            const personGroup = container.append('g')
                .attr('transform', `translate(${person.x - baseX}, ${person.y - baseY})`);
            
            // Colores del dise√±o oscuro elegante
            const cardColors = {
                background: '#2d1b69', // Morado oscuro
                border: '#1a103f',     // Morado m√°s oscuro
                text: '#ffffff',       // Blanco
                secondary: '#b8a9d9',  // Morado claro
                accent: '#8b5cf6',     // Violeta
                divider: '#4c1d95'     // Morado medio para divisores
            };
            
            // Fondo de la tarjeta con sombra
            personGroup.append('rect')
                .attr('class', 'person-card-shadow')
                .attr('x', -cardWidth/2 + 3)
                .attr('y', -cardHeight/2 + 3)
                .attr('width', cardWidth)
                .attr('height', cardHeight)
                .attr('rx', 20)
                .style('fill', '#000000')
                .style('opacity', '0.3');
            
            // Tarjeta principal
            personGroup.append('rect')
                .attr('class', 'person-card')
                .attr('x', -cardWidth/2)
                .attr('y', -cardHeight/2)
                .attr('width', cardWidth)
                .attr('height', cardHeight)
                .attr('rx', 20)
                .style('fill', cardColors.background)
                .style('stroke', cardColors.border)
                .style('stroke-width', '2');
            
            // Avatar placeholder (c√≠rculo blanco)
            personGroup.append('circle')
                .attr('cx', 0)
                .attr('cy', -cardHeight/2 + 35)
                .attr('r', 25)
                .style('fill', '#ffffff')
                .style('opacity', '0.1')
                .style('stroke', cardColors.secondary)
                .style('stroke-width', '1');
            
            // Nombre principal con tama√±o de fuente variable
            const calculateNameLayout = (name) => {
                const maxWidth = cardWidth - 30; // Margen de 15px a cada lado
                const maxLines = 3; // M√°ximo 3 l√≠neas
                
                // Funci√≥n para medir el ancho del texto
                const measureText = (text, fontSize) => {
                    const tempText = personGroup.append('text')
                        .style('font-size', fontSize + 'px')
                        .style('font-weight', '600')
                        .text(text);
                    const bbox = tempText.node().getBBox();
                    tempText.remove();
                    return bbox.width;
                };
                
                // Determinar el tama√±o de fuente √≥ptimo
                let fontSize = 14;
                let nameLines = [];
                
                // Probar con diferentes tama√±os de fuente
                for (let size = 14; size >= 8; size--) {
                    const words = name.split(' ');
                    nameLines = [];
                    let currentLine = '';
                    
                    for (let word of words) {
                        const testLine = currentLine ? currentLine + ' ' + word : word;
                        if (measureText(testLine, size) <= maxWidth) {
                            currentLine = testLine;
                        } else {
                            if (currentLine) {
                                nameLines.push(currentLine);
                                currentLine = word;
                            } else {
                                // Si una palabra sola es muy larga, la cortamos
                                nameLines.push(word.substring(0, Math.floor(maxWidth / (size * 0.6))));
                                currentLine = '';
                            }
                        }
                    }
                    
                    if (currentLine) {
                        nameLines.push(currentLine);
                    }
                    
                    // Si cabe en el n√∫mero m√°ximo de l√≠neas, usar este tama√±o
                    if (nameLines.length <= maxLines) {
                        fontSize = size;
                        break;
                    }
                }
                
                return { nameLines, fontSize };
            };
            
            const { nameLines, fontSize } = calculateNameLayout(person.name);
            const lineHeight = fontSize * 1.2; // Espaciado entre l√≠neas
            
            nameLines.forEach((line, i) => {
                personGroup.append('text')
                    .attr('class', 'person-text name')
                    .attr('y', -cardHeight/2 + 75 + (i * lineHeight))
                    .style('font-size', fontSize + 'px')
                    .style('font-weight', '600')
                    .style('fill', cardColors.text)
                    .style('text-anchor', 'middle')
                    .text(line);
            });
            
            // Calcular la posici√≥n Y del lugar de nacimiento basada en el n√∫mero de l√≠neas del nombre
            const nameHeight = nameLines.length * lineHeight;
            const locationY = -cardHeight/2 + 75 + nameHeight + 15; // 15px de espacio despu√©s del nombre
            
            // L√≠nea divisoria (solo separa el nombre)
            personGroup.append('line')
                .attr('x1', -cardWidth/2 + 15)
                .attr('y1', locationY - 12) // 12px antes del lugar para m√°s espacio
                .attr('x2', cardWidth/2 - 15)
                .attr('y2', locationY - 12)
                .style('stroke', cardColors.divider)
                .style('stroke-width', '1');
            
            // Lugar de nacimiento con pin de ubicaci√≥n (optimizado)
            if (person.birthPlace) {
                const placeText = person.birthPlace.length > 18 ? 
                    person.birthPlace.substring(0, 16) + '...' : person.birthPlace;
                
                // Pin de ubicaci√≥n üìç
                personGroup.append('text')
                    .attr('class', 'person-text location-icon')
                    .attr('x', -cardWidth/2 + 15)
                    .attr('y', locationY + 2)
                    .style('font-size', '10px')
                    .style('fill', cardColors.text)
                    .style('text-anchor', 'start')
                    .text('üìç');
                
                personGroup.append('text')
                    .attr('class', 'person-text location')
                    .attr('x', -cardWidth/2 + 25)
                    .attr('y', locationY + 2)
                    .style('font-size', '9px')
                    .style('fill', cardColors.text)
                    .style('text-anchor', 'start')
                    .text(placeText.toUpperCase());
            }
            
            // DEBUG: Log de fechas para entender qu√© datos llegan
            console.log(`üîç DEBUG FECHAS para ${person.name}:`, {
                birthDate: person.birthDate,
                deathDate: person.deathDate,
                birthDateType: typeof person.birthDate,
                deathDateType: typeof person.deathDate
            });
            
            // Fechas de nacimiento y defunci√≥n (optimizado)
            const getYear = (dateStr) => {
                if (!dateStr || dateStr === 'NaN') return '?';
                
                try {
                    let date;
                    
                    // Si es formato "Date(year,month,day)"
                    if (dateStr.includes('Date(')) {
                        const match = dateStr.match(/Date\((\d+),(\d+),(\d+)\)/);
                        if (match) {
                            const [, year, month, day] = match;
                            date = new Date(parseInt(year), parseInt(month), parseInt(day));
                        } else {
                            return '?';
                        }
                    } else {
                        date = new Date(dateStr);
                    }
                    
                    return isNaN(date.getTime()) ? '?' : date.getFullYear();
                } catch (e) {
                    return '?';
                }
            };
            
            const birthYear = getYear(person.birthDate);
            const deathYear = getYear(person.deathDate);
            
            console.log(`üìÖ A√ëOS CALCULADOS para ${person.name}:`, { birthYear, deathYear });
            
            // ELIMINADO: A√±os principales que se superponen con la ciudad
            // Los a√±os ya se muestran en la secci√≥n "FECHAS" abajo
            
            // ELIMINADO: L√≠nea divisoria antigua y secci√≥n "FECHAS"
            // Ahora la l√≠nea solo separa el nombre, y las fechas van directamente
            
            // Fechas detalladas (formato corregido)
            const formatDate = (dateStr) => {
                console.log(`üîß formatDate recibi√≥: "${dateStr}" (tipo: ${typeof dateStr})`);
                
                if (!dateStr || dateStr === 'NaN') {
                    console.log(`‚ùå Fecha vac√≠a o NaN: ${dateStr}`);
                    return '?';
                }
                
                try {
                    let date;
                    
                    // Si es formato "Date(year,month,day)"
                    if (dateStr.includes('Date(')) {
                        const match = dateStr.match(/Date\((\d+),(\d+),(\d+)\)/);
                        if (match) {
                            const [, year, month, day] = match;
                            // Los meses en JavaScript van de 0-11, as√≠ que restamos 1
                            date = new Date(parseInt(year), parseInt(month), parseInt(day));
                            console.log(`üìÖ Date parseado de Date():`, date);
                        } else {
                            console.log(`‚ùå Formato Date() inv√°lido: ${dateStr}`);
                            return '?';
                        }
                    } else {
                        // Fecha normal
                        date = new Date(dateStr);
                        console.log(`üìÖ Date creado:`, date);
                    }
                    
                    if (isNaN(date.getTime())) {
                        console.log(`‚ùå Fecha inv√°lida: ${dateStr}`);
                        return '?';
                    }
                    
                    const formatted = date.toLocaleDateString('es-ES', { 
                        day: '2-digit', 
                        month: '2-digit', 
                        year: 'numeric' 
                    });
                    console.log(`‚úÖ Fecha formateada: ${formatted}`);
                    return formatted;
                } catch (e) {
                    console.log(`‚ùå Error formateando fecha:`, e);
                    return '?';
                }
            };
            
            const birthDate = formatDate(person.birthDate);
            const deathDate = formatDate(person.deathDate);
            
            console.log(`üìã FECHAS FINALES para ${person.name}:`, { birthDate, deathDate });
            
            // Calcular posici√≥n Y de las fechas despu√©s del lugar
            const datesY = locationY + 20; // 20px despu√©s del lugar
            
            personGroup.append('text')
                .attr('class', 'person-text birth-date')
                .attr('x', -cardWidth/2 + 15)
                .attr('y', datesY)
                .style('font-size', '9px')
                .style('fill', cardColors.secondary)
                .style('text-anchor', 'start')
                .text(`Nac: ${birthDate}`);
            
            personGroup.append('text')
                .attr('class', 'person-text death-date')
                .attr('x', -cardWidth/2 + 15)
                .attr('y', datesY + 15)
                .style('font-size', '9px')
                .style('fill', cardColors.secondary)
                .style('text-anchor', 'start')
                .text(`Def: ${deathDate}`);
            
            // Lugar de defunci√≥n (si es diferente al de nacimiento)
            if (person.deathPlace && person.deathPlace !== person.birthPlace) {
                const deathPlaceText = person.deathPlace.length > 18 ? 
                    person.deathPlace.substring(0, 16) + '...' : person.deathPlace;
                
                personGroup.append('text')
                    .attr('class', 'person-text death-place')
                    .attr('x', -cardWidth/2 + 15)
                    .attr('y', datesY + 30)
                    .style('font-size', '8px')
                    .style('fill', cardColors.secondary)
                    .style('text-anchor', 'start')
                    .text(deathPlaceText);
            }
            
            // ID en la esquina inferior derecha
            personGroup.append('text')
                .attr('class', 'person-text id')
                .attr('x', cardWidth/2 - 10)
                .attr('y', cardHeight/2 - 8)
                .style('font-size', '8px')
                .style('fill', cardColors.secondary)
                .style('text-anchor', 'end')
                .text(person.id);
            
            // Indicador de estado (vivo/fallecido) con color
            const isDeceased = person.deathDate && person.deathDate !== 'NaN';
            personGroup.append('circle')
                .attr('cx', -cardWidth/2 + 10)
                .attr('cy', cardHeight/2 - 10)
                .attr('r', 4)
                .style('fill', isDeceased ? '#ef4444' : cardColors.accent);
        }
        
        // Funci√≥n para renderizar conexiones padre-hijo (estilo √°rbol geneal√≥gico)
        function renderParentChildConnections(container, allUnits) {
            console.log('üîó Renderizando conexiones padre-hijo...');
            
            allUnits.forEach(unit => {
                const hasChildren = (unit.children && unit.children.length > 0);
                const hasChildMarriages = (unit.childMarriages && unit.childMarriages.length > 0);
                
                if (unit.collapsed || (!hasChildren && !hasChildMarriages)) return;
                
                // Buscar las posiciones de los hijos individuales
                const childPositions = (unit.children || []).map(child => {
                    // IMPORTANTE: No conectar a una persona consigo misma si es parte del matrimonio actual
                    if (unit.type === 'marriage') {
                        if (unit.spouse1.id === child.id || unit.spouse2.id === child.id) {
                            console.log(`‚ö†Ô∏è Evitando autoconexi√≥n: ${child.name} es parte del matrimonio ${unit.spouse1.name}+${unit.spouse2.name}`);
                            return null; // No conectar a s√≠ mismo
                        }
                    }
                    
                    // Buscar la unidad del hijo
                    const childUnit = allUnits.find(u => {
                        if (u.type === 'marriage') {
                            return u.spouse1.id === child.id || u.spouse2.id === child.id;
                        } else if (u.type === 'single') {
                            return u.person.id === child.id;
                        }
                        return false;
                    });
                    
                    if (childUnit) {
                        let childX, childY;
                        
                        if (childUnit.type === 'marriage') {
                            // Para matrimonios, usar la posici√≥n X de la tarjeta espec√≠fica del hijo
                            if (childUnit.spouse1.id === child.id) {
                                childX = childUnit.spouse1.x;
                                childY = childUnit.spouse1.y;
            } else {
                                childX = childUnit.spouse2.x;
                                childY = childUnit.spouse2.y;
                            }
                            console.log(`üîç Hijo casado encontrado: ${child.name} en tarjeta (${childX}, ${childY}), matrimonio en (${childUnit.x}, ${childUnit.y})`);
                } else {
                            // Para solteros, usar la posici√≥n de la persona
                            childX = childUnit.person.x;
                            childY = childUnit.person.y;
                            console.log(`üîç Hijo soltero encontrado: ${child.name} en (${childX}, ${childY})`);
                        }
                        
                        return { x: childX, y: childY, name: child.name };
                    }
                    
                    console.log(`‚ö†Ô∏è Hijo no encontrado: ${child.name}`);
                    return null;
                }).filter(Boolean);
                
                // ELIMINADO: L√≥gica de matrimonios hijos - solo usar conexiones padre-hijo individuales
                const childMarriagePositions = [];
                // (unit.childMarriages || []).forEach(childMarriage => {
                //     console.log(`üîç Matrimonio hijo encontrado: ${childMarriage.spouse1.name}+${childMarriage.spouse2.name} en (${childMarriage.x}, ${childMarriage.y})`);
                //     
                //     // Crear conexi√≥n individual a cada c√≥nyuge
                //     childMarriagePositions.push({ 
                //         x: childMarriage.spouse1.x, 
                //         y: childMarriage.spouse1.y, 
                //         name: childMarriage.spouse1.name,
                //         isSpouse: true,
                //         spouseIndex: 1
                //     });
                //     childMarriagePositions.push({ 
                //         x: childMarriage.spouse2.x, 
                //         y: childMarriage.spouse2.y, 
                //         name: childMarriage.spouse2.name,
                //         isSpouse: true,
                //         spouseIndex: 2
                //     });
                // });
                
                // Combinar todas las posiciones de hijos
                const allChildPositions = [...childPositions, ...childMarriagePositions];
                
                if (allChildPositions.length === 0) return;
                
                // L√≠neas salen desde el c√≠rculo de colapso/expand (rojo/verde)
                const collapseCircleY = unit.y + 70; // Posici√≥n Y del c√≠rculo de colapso
                // L√≠nea vertical desde el c√≠rculo hacia abajo - longitud fija
                const standardVerticalLength = 60; // Longitud est√°ndar desde el c√≠rculo
                const horizontalLineY = collapseCircleY + standardVerticalLength;
                
                // Verificar que estamos conectando hacia hijos que est√°n m√°s abajo Y eliminar autoconexiones
                let validChildren = allChildPositions.filter(child => child && child.y > unit.y);
                
                // IMPORTANTE: Eliminar autoconexiones tambi√©n en el renderizado
                if (unit.type === 'marriage') {
                    validChildren = validChildren.filter(child => {
                        // No conectar a los c√≥nyuges del matrimonio actual (solo si NO es un matrimonio hijo)
                        const isSpouse = (child.name === unit.spouse1.name) || (child.name === unit.spouse2.name);
                        const isFromChildMarriage = child.isSpouse; // Es un c√≥nyuge de un matrimonio hijo
                        
                        // Debug espec√≠fico para Emiliana
                        if (child.name.includes('Emiliana') || unit.spouse1.name.includes('Emiliana') || unit.spouse2.name.includes('Emiliana')) {
                            console.log(`üîç VERIFICANDO AUTOCONEXI√ìN: child="${child.name}", spouse1="${unit.spouse1.name}", spouse2="${unit.spouse2.name}", isSpouse=${isSpouse}, isFromChildMarriage=${isFromChildMarriage}`);
                        }
                        
                        if (isSpouse && !isFromChildMarriage) {
                            console.log(`‚ö†Ô∏è AUTOCONEXI√ìN EVITADA EN RENDERIZADO: ${child.name} es parte del matrimonio ${unit.spouse1.name}+${unit.spouse2.name}`);
                            return false;
                        }
                        return true;
                    });
                }
                
                if (validChildren.length === 0) {
                    console.log(`‚ö†Ô∏è ${unit.type === 'marriage' ? unit.spouse1.name : unit.person.name}: No hay hijos v√°lidos debajo`);
                    return;
                }
                console.log(`üîç Conectando desde Y=${unit.y} hacia hijos en Y=${validChildren.map(c => c.y).join(',')}`);
                const childPositionsFiltered = validChildren;
                
                // Debug: mostrar informaci√≥n detallada de la unidad padre y sus hijos
                const parentName = unit.type === 'marriage' ? `${unit.spouse1.name}+${unit.spouse2.name}` : unit.person.name;
                console.log(`üå≥ Padre: ${parentName} tiene ${childPositionsFiltered.length} hijos:`);
                childPositionsFiltered.forEach((child, i) => {
                    console.log(`  ${i+1}. ${child.name} en (${child.x}, ${child.y})`);
                });
                
                // Conexiones directas e individuales desde el c√≠rculo de colapso hasta cada hijo
                const standardChildConnectionLength = 60;
                
                childPositionsFiltered.forEach(child => {
                    // L√≠nea vertical corta desde el c√≠rculo de colapso
                    const shortVerticalLength = 30;
                    const branchPointY = collapseCircleY + shortVerticalLength;
                    
                    container.append('line')
                        .attr('class', 'parent-child-link')
                        .attr('x1', unit.x)
                        .attr('y1', collapseCircleY)
                        .attr('x2', unit.x)
                        .attr('y2', branchPointY)
                        .style('stroke', '#b8a9d9')
                        .style('stroke-width', '2.5')
                        .style('stroke-linecap', 'round');
                    
                    // L√≠nea diagonal directa hasta el punto arriba del hijo
                    const childTopY = child.y - cardHeight/2 - standardChildConnectionLength;
                    
                    container.append('line')
                        .attr('class', 'parent-child-link')
                        .attr('x1', unit.x)
                        .attr('y1', branchPointY)
                        .attr('x2', child.x)
                        .attr('y2', childTopY)
                        .style('stroke', '#b8a9d9')
                        .style('stroke-width', '2.5')
                        .style('stroke-linecap', 'round');
                    
                    // L√≠nea vertical final hacia el hijo
                    container.append('line')
                        .attr('class', 'parent-child-link')
                        .attr('x1', child.x)
                        .attr('y1', childTopY)
                        .attr('x2', child.x)
                        .attr('y2', child.y - cardHeight/2)
                        .style('stroke', '#b8a9d9')
                        .style('stroke-width', '2.5')
                        .style('stroke-linecap', 'round');
                });
                
                // Log apropiado seg√∫n el tipo de unidad
                if (unit.type === 'marriage') {
                    console.log(`üå≥ Conexiones desde ${unit.spouse1.name}+${unit.spouse2.name} a ${childPositionsFiltered.length} hijos v√°lidos`);
                } else {
                    console.log(`üå≥ Conexiones desde ${unit.person.name} (soltero/a) a ${childPositionsFiltered.length} hijos v√°lidos`);
                }
            });
        }
        
        // Funci√≥n para toggle collapse/expand de matrimonios y personas solteras
        function toggleMarriageCollapse(unit) {
            // Buscar la unidad correspondiente en currentUnits para asegurar que trabajamos con la referencia correcta
            const targetUnit = currentUnits.find(u => {
                if (u.type === 'marriage' && unit.type === 'marriage') {
                    return u.spouse1.id === unit.spouse1.id && u.spouse2.id === unit.spouse2.id;
                } else if (u.type === 'single' && unit.type === 'single') {
                    return u.person.id === unit.person.id;
                }
                return false;
            });
            
            if (!targetUnit) {
                console.error('‚ùå No se encontr√≥ la unidad en currentUnits');
                return;
            }
            
            targetUnit.collapsed = !targetUnit.collapsed;
            
            // Log apropiado seg√∫n el tipo de unidad
            if (targetUnit.type === 'marriage') {
                console.log(`${targetUnit.collapsed ? 'üìÅ' : 'üìÇ'} ${targetUnit.spouse1.name} ‚Üê‚Üí ${targetUnit.spouse2.name} (collapsed: ${targetUnit.collapsed})`);
            } else if (targetUnit.type === 'single') {
                console.log(`${targetUnit.collapsed ? 'üìÅ' : 'üìÇ'} ${targetUnit.person.name} (soltero/a) (collapsed: ${targetUnit.collapsed})`);
            }
            
            // Marcar descendientes como ocultos/visibles recursivamente
            toggleDescendantsVisibility(targetUnit, targetUnit.collapsed, currentUnits);
            
            // Debug: mostrar estado antes del filtrado
            console.log('üîç Estado de todas las unidades antes del filtrado:');
            currentUnits.forEach(u => {
                const name = u.type === 'marriage' ? `${u.spouse1.name}+${u.spouse2.name}` : u.person.name;
                console.log(`  ${name}: hidden=${u.hidden}, collapsed=${u.collapsed}`);
            });
            
            // Re-calcular layout solo con unidades visibles
            const visibleUnits = currentUnits.filter(u => !u.hidden);
            console.log(`üéØ Unidades visibles: ${visibleUnits.length}/${currentUnits.length}`);
            
            const positioned = calculateMarriageLayout(visibleUnits);
            renderTree(positioned);
        }
        
        // Funci√≥n auxiliar para ocultar/mostrar descendientes recursivamente
        function toggleDescendantsVisibility(unit, shouldHide, allUnits) {
            unit.children.forEach(child => {
                // Buscar la unidad del hijo (matrimonio o soltera)
                const childUnit = allUnits.find(u => {
                    if (u.type === 'marriage') {
                        return u.spouse1.id === child.id || u.spouse2.id === child.id;
                    } else if (u.type === 'single') {
                        return u.person.id === child.id;
                    }
                    return false;
                });
                
                if (childUnit) {
                    childUnit.hidden = shouldHide;
                    
                    if (childUnit.type === 'marriage') {
                        console.log(`${shouldHide ? 'üôà' : 'üëÅÔ∏è'} ${childUnit.spouse1.name} ‚Üê‚Üí ${childUnit.spouse2.name} ‚Üí hidden=${childUnit.hidden}`);
                } else {
                        console.log(`${shouldHide ? 'üôà' : 'üëÅÔ∏è'} ${childUnit.person.name} (soltero/a) ‚Üí hidden=${childUnit.hidden}`);
                    }
                    
                    // Recursivamente ocultar/mostrar sus descendientes
                    // Solo si estamos ocultando O si la unidad hijo no est√° colapsada
                    if (shouldHide) {
                        // Si estamos ocultando, ocultar todos los descendientes
                        toggleDescendantsVisibility(childUnit, true, allUnits);
                    } else if (!childUnit.collapsed) {
                        // Si estamos mostrando y la unidad hijo no est√° colapsada, mostrar sus descendientes
                        toggleDescendantsVisibility(childUnit, false, allUnits);
                    }
                    // Si estamos mostrando pero la unidad hijo est√° colapsada, no mostrar sus descendientes
                }
            });
        }
        
        // Funciones de control de interfaz
        function resetZoom() {
            if (svg) {
                svg.transition().duration(750).call(
                    d3.zoom().transform,
                    d3.zoomIdentity
                );
            }
        }
        
        function expandAll() {
            if (currentUnits.length === 0) return;
            
            console.log('üìÇ Expandiendo todas las unidades...');
            
            // Expandir y mostrar todas las unidades
            currentUnits.forEach(unit => {
                unit.collapsed = false;
                unit.hidden = false;
            });
            
            // Re-calcular y renderizar
            const positioned = calculateMarriageLayout(currentUnits);
            renderTree(positioned);
        }
        
        function collapseAll() {
            if (currentUnits.length === 0) return;
            
            console.log('üìÅ Colapsando todas las unidades...');
            
            // Encontrar unidades ra√≠z (sin padres)
            const rootUnits = currentUnits.filter(unit => {
                let unitPersonIds = [];
                if (unit.type === 'marriage') {
                    unitPersonIds = [unit.spouse1.id, unit.spouse2.id];
                } else if (unit.type === 'single') {
                    unitPersonIds = [unit.person.id];
                }
                
                // Verificar si alguna persona de esta unidad es hijo de otra unidad
                const hasParents = currentUnits.some(parentUnit => 
                    parentUnit.children.some(child => unitPersonIds.includes(child.id))
                );
                
                return !hasParents; // Es ra√≠z si no tiene padres
            });
            
            // Colapsar desde las ra√≠ces
            rootUnits.forEach(root => {
                root.collapsed = true;
                toggleDescendantsVisibility(root, true, currentUnits);
            });
            
            // Re-renderizar solo unidades visibles
            const visibleUnits = currentUnits.filter(u => !u.hidden);
            const positioned = calculateMarriageLayout(visibleUnits);
            renderTree(positioned);
        }
        
        // Funci√≥n principal
        async function init() {
            try {
                const rawData = await loadData();
                if (rawData.length === 0) return;
                
                currentUnits = buildMarriageStructure(rawData);
                const positionedMarriages = calculateMarriageLayout(currentUnits);
                renderTree(positionedMarriages);
                
            } catch (error) {
                console.error('Error inicializando:', error);
                updateStatus('Error: ' + error.message);
            }
        }
        
        // Inicializar cuando la p√°gina carga
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
